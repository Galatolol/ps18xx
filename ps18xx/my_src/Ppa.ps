%!PS-Adobe-3.0
%%Pages: 4
%%EndComments
%%BeginProlog
/18xxVariant (18pa) def
/orientNumbers false def
% ----------------------------------------------------------------------
%				COPYRIGHT
%		Matthias Klose (doko@cs.tu-berlin.de)
%
% ps18xx is "postcard" ware. If you use this code or part of this,
% you are invited to send me a nice railway postcard to the address below.
% In September 1995 I got the first and only card :-(
%
% You are allowed to use this code and to modify the source, provided
% you leave this copyright notice and the acknowledgements in it.
%
% You are allowed to include the code in your own programs, provided
% - you distribute your programs for free or for a fee, which is not
%   more than DM 20,-- or $15.
% - you show the copyright notice in the same places as your own
%   copyright notice,
% - you ask the users of your program to send a postcard, if they use
%   this or modified code.
%
% You are not allowed to include this or derived code in any
% 18xx related program that is distributed as commercial software.
%
%						Matthias Klose
%						Dillgesstr. 30
%						D-12249 Berlin
%						doko@cs.tu-berlin.de
%

% ----------------------------------------------------------------------
%				ACKNOWLEDGMENTS
% ----------------------------------------------------------------------

% Several people helped in debugging existing maps and tiles. Following
% people made contributions:

% - Paul R. Work (pwork@ss2.sews.wpafb.af.mil) created the 1835 and 1837
%   map, 1835 and 1837 specific tiles and the tile list, added bridges.

% - Nick Roworth (nroworth@uk.oracle.com) created the 1829-south map
%   and debugged the 1853 and other map and tiles.

% - Steve Thomas (Steve.Thomas@insignia.co.uk) created the 1856 map and
%   1856 specific tiles and added code to print the map labels in reverse
%   order.
%   He reworked the code to allow sitting tiles, added port symbols and
%   made the 1839 Italy, 1850 Sicily, 1870, 1825 U1 and 1899 (China) games
/cm { 28.35 mul } def
/glob-known { where dup  { exch pop } if } def
/selectfont glob-known not {
	/selectfont {
		exch findfont exch scalefont setfont
	} def
} if
/rectpath {
	dup type /arraytype eq {
		aload pop
	} if
	4 2 roll moveto 1 index 0 rlineto 0 exch rlineto neg 0 rlineto closepath
} def
/rectclip glob-known not {
	/rectclip {
			newpath rectpath clip newpath
	} def
} if
/rectfill glob-known not {
	/rectfill {
		gsave
			newpath rectpath fill
		grestore
	} def
} if
/rectstroke glob-known not {
	/rectstroke {
		gsave
			newpath rectpath stroke
		grestore
	} def
} if
/rightshow {
	dup stringwidth pop
	4 -1 roll exch sub
	3 -1 roll moveto
	show
} def
/centershow {
	dup stringwidth pop 2 div
	4 -1 roll exch sub
	3 -1 roll moveto
	show
} def
/xycentershow {
	dup stringwidth pop 2 div
	4 -1 roll exch sub
	3 1 roll
	dup stringheight add 2 div neg 3 -1 roll add
	exch 3 1 roll moveto
	show
} def
/charheight {
	gsave
		newpath
		0 0 moveto
		false charpath
		flattenpath
		pathbbox
		exch pop
		3 -1 roll pop
	grestore
} def
/stringheight {
	/lly 0.0 def
	/ury 0.0 def
	{
		( ) dup 0 4 -1 roll put
		charheight
		dup ury gt { /ury exch def } { pop } ifelse
		dup lly lt { /lly exch def } { pop } ifelse
	} forall
	lly ury
} def
/toupper {
	/s exch def
	0 1 s length 1 sub
	{
		dup
		/c s 3 -1 roll get def
		c 97 ge c 122 le and
		{ /c c 32 sub def }
		if
		s exch c put
	} for
	s
} def
/string5 6 string def
/18xx-dict 600 dict def
18xx-dict begin
/maxGeneric 850 def
/hexSide 2 cm def
/hexHeight hexSide 30 cos mul def
18xxVariant (1837) eq
18xxVariant (1854) eq or
18xxVariant (1838) eq or
18xxVariant (1837sx) eq or
18xxVariant (1865sar) eq or
18xxVariant (1880) eq or
18xxVariant (1881) eq or
18xxVariant (18gb) eq or
{
	/stationRadius //hexHeight 3.35 div def
} {
	/stationRadius //hexHeight 2.65 div def
} ifelse
/trackWidth 6 def
/hex_x0 270 cos //hexSide mul def   /hex_y0 270 sin //hexSide mul def
/hex_x1 210 cos //hexSide mul def   /hex_y1 210 sin //hexSide mul def
/hex_x2 150 cos //hexSide mul def   /hex_y2 150 sin //hexSide mul def
/hex_x3  90 cos //hexSide mul def   /hex_y3  90 sin //hexSide mul def
/hex_x4  30 cos //hexSide mul def   /hex_y4  30 sin //hexSide mul def
/hex_x5 330 cos //hexSide mul def   /hex_y5 330 sin //hexSide mul def
/mtRadius 0.55 cm def
/mountain_x0 210 cos mtRadius mul def
/mountain_y0 210 sin mtRadius mul def
/mountain_x1  90 cos mtRadius mul def
/mountain_y1  90 sin mtRadius mul def
/mountain_x2 330 cos mtRadius mul def
/mountain_y2 330 sin mtRadius mul def
/mineSize //hexHeight 2.9 div def
/mineBoxX //hexHeight 2.4 div def
/mineBoxY //hexHeight 4.9 div def
/pickX //hexHeight 5.2 div def
/pickY //hexHeight 5.3 div def
/pickTopX //hexHeight 5.0 div def
/pickTopY //hexHeight 5.0 div def
/pickTopOrig //hexHeight 22.2 div def
/pickWidth 2 def
/tlGround 0 def
/tlYellow 1 def
/tlGreen  2 def
/tlBrown  3 def
/tlRusset 4 def
/tlGray   5 def
/tlRed    6 def
/tlSpecialArea 7 def
/tlCopper 8 def
/tlBlue   9 def
/tlBarr   10 def
/tlPyjama 11 def
/tlNoHex  12 def
/tlTransparent  13 def
/tlPlain         0 def
/tlWater         1 def
/tlWater2        2 def
/tlWater3        3 def
/tlMountain      4 def
/tlMountain2     5 def
/tlHill          6 def
/tlHillWater     7 def
/tlMountainWater 8 def
/tlWater4        9 def
/tlAlp          10 def
/tlAppennine    11 def
/tlPort			12 def
/tlGrass		13 def
/tlTree 		14 def
/tlYucca		15 def
/tlPort2		16 def
/tlPrivate		17 def
/tlPickShovel	18 def
/tlMountain3    19 def
/stdGauge     0 def
/narrowGauge  1 def
/dualGauge    2 def
/tunnelGauge  3 def
/twinGauge    4 def
/tripleGauge  5 def
/quadGauge    6 def
/thinGauge    7 def
/orSouthWest 0 def
/orWest      1 def
/orNorthWest 2 def
/orNorthEast 3 def
/orEast      4 def
/orSouthEast 5 def
/noStation 0 def
/valRadius 0.28 cm def
/valADist //valRadius 0.7 cm add def
/valBDist //valRadius 0.5 cm add def
/valCDist //valRadius 0.2 cm add def
/valDDist //valRadius 1.2 cm add def
/valEDist //valRadius 0.15 cm add def
/valFont { /Helvetica 10 } def
/labFDist 1.0 cm def
/labEDist 0.45 cm def
/labDDist 1.5 cm def
/labCDist 0.5 cm def
/labBDist 1.2 cm def
/labADist 0.7 cm def
/axisNormal   0 def
/axisNumBack  1 def
/axisLetBack  2 def
/axisBothBack 3 def
/axisDirection //axisNormal def
/tileSitting false def
/axesSwapped false def
/useSexavigenary false def
/TilePath {
	newpath
	//hex_x0 //hex_y0 moveto
	//hex_x1 //hex_y1 lineto
	//hex_x2 //hex_y2 lineto
	//hex_x3 //hex_y3 lineto
	//hex_x4 //hex_y4 lineto
	//hex_x5 //hex_y5 lineto
	closepath
} bind def
/MountainPath {
	newpath
	//mountain_x0 //mountain_y0 moveto
	//mountain_x1 //mountain_y1 lineto
	//mountain_x2 //mountain_y2 lineto
	closepath
} bind def
/HillPath {
	newpath
	//mountain_x0 //mountain_y0 moveto
	//mountain_x1 //mountain_y1 0.3 mul lineto
	//mountain_x2 //mountain_y2 lineto
	closepath
} bind def
/waveRadius 0.2 cm def
/waveHeight //waveRadius 45 cos mul def
/WaterPath {
	newpath
	//waveHeight -2 mul //waveHeight neg //waveRadius 135 45 arcn
	0 //waveHeight //waveRadius 225 315 arc
	//waveHeight 2 mul //waveHeight neg //waveRadius 135 45 arcn
} bind def
/Anchor {
	gsave
		2 setlinewidth
		newpath
		0 0 stationRadius .75 mul 240 300 arc stroke
		newpath
		0 stationRadius .75 mul neg moveto
		0 0.375 stationRadius mul lineto stroke
		newpath
		0.3 stationRadius mul neg 0 moveto
		0.3 stationRadius mul 0 lineto stroke
		newpath
		1 setlinewidth
		0 stationRadius .475 mul stationRadius .1 mul 0 360 arc stroke
	grestore
} def
/TileBorder {
	gsave
		HexPath stroke
	grestore
} def
/haveColor glob-known not {
  /haveColor false def
  systemdict /statusdict known {
    statusdict /processcolors known {
      /haveColor processcolors 1 ne def
    } if
  } if
} if
/ColorNameTable [
	(beige)
	(yellow)
	(green)
	(brown)
	(russet)
	(gray)
	(red)
	(special)
	(copper)
	(blue)
	(barrier)
	(pyjama)
	(nohex)
	(transparent)
] def
haveColor {
	/colorTable [
		[ 1    1    1    ]
		[ 1    1    0    ]
		[ 0    1    0    ]
		[ 0.2  0.3  0.7  ]
		[ 0.5  0.35 0.25 ]
		[ 0.5  0.5  0.5  ]
		[ 1    0    0    ]
		[ 0.5  0.5  0    ]
		[ 0.28 0.55 0.8  ]
		[ 0    0    0.6  ]
		[ 0    0    1    ]
		[ 0.3  0.3  0.3  ]
	] def
	/c1 { 255 div } def
	/XcolorTable [
		[ 245 c1 245 c1 220 c1 ]
        [ 255 c1 255 c1   102 c1 ]
		[ 120 c1 255 c1 120 c1 ]
		[ 187 c1 148 c1  83 c1 ]
		[ 238 c1 118 c1  33 c1 ]
		[ 190 c1 190 c1 190 c1 ]
		[ 255 c1 100 c1 100 c1 ]
		[ 255 c1 228 c1 196 c1 ]
		[ 238 c1 135 c1  75 c1 ]
		[  98 c1 210 c1 247 c1 ]
		[  30 c1 144 c1 255 c1 ]
		[ 176 c1  48 c1  96 c1 ]
		[ 255 c1 255 c1 255 c1 ]
		[ 255 c1 255 c1 255 c1 ]
	] def
} {
	/grayTable [
		1
		0.97
		0.9
		0.7
		0.7
		0.5
		0.4
		0.99
		0.8
		0.5
		0.3
		0.3
		1
		1
	] def
} ifelse
/TileColor {
	/tileColor exch def
	currentgray
	tileColor //tlBarr le {
		tileColor haveColor {
			XcolorTable exch get
			aload pop
			setrgbcolor
		} {
			grayTable exch get
			setgray
		} ifelse
		TilePath fill
	} if
	tileColor tlPyjama eq {
		gsave
			TilePath clip
			newpath
			//hexSide dup add setlinewidth
			240 cos //hexHeight mul  240 sin //hexHeight mul
				moveto
			 60 cos //hexHeight mul   60 sin //hexHeight mul
				lineto
			[ 0.5 cm 0.5 cm ] 0 setdash
			//tlRusset haveColor {
				XcolorTable exch get
				aload pop
				setrgbcolor
			} {
				grayTable exch get
				setgray
			} ifelse
			stroke
			240 cos //hexHeight mul  240 sin //hexHeight mul
				moveto
			 60 cos //hexHeight mul   60 sin //hexHeight mul
				lineto
			[ 0.5 cm 0.5 cm ] 0.5 cm setdash
			//tlGray haveColor {
				XcolorTable exch get
				aload pop
				setrgbcolor
			} {
				grayTable exch get
				setgray
			} ifelse
			stroke
		grestore
	} if
	setgray
} def
/TileNumber {
	gsave
		/tnum exch def
		/tileCodes glob-known {
			/tile tileCodes tnum get def
			tile 7 get
		} {
			tnum string5 cvs
		} ifelse
		0 hexSide neg translate
		-30 rotate
		/Helvetica 8 selectfont
		-0.1 cm 0.1 cm 3 -1 roll
		rightshow
	grestore
} def
/StrokeTrack {
	/trackType exch def
	currentlinewidth
	//stdGauge trackType eq {
		trackWidth setlinewidth stroke
	} if
	//tunnelGauge trackType eq {
		trackWidth setlinewidth
		currentdash
		[ 6 6 ] 0 setdash
		stroke
		setdash
	} if
	//narrowGauge trackType eq {
		gsave
			gsave
				trackWidth setlinewidth stroke
			grestore
			1 setgray
			trackWidth 0.7 mul setlinewidth stroke
		grestore
		trackWidth setlinewidth
		currentdash
		[ 6 6 ] 0 setdash
		stroke
		setdash
	} if
	//dualGauge trackType eq {
		gsave
		trackWidth setlinewidth stroke
		grestore
		currentgray 1 setgray
		trackWidth 0.4 mul setlinewidth stroke
		setgray
	} if
	//twinGauge trackType eq {
		gsave
		trackWidth 2.5 mul setlinewidth stroke
		grestore
		currentgray 1 setgray
		trackWidth 0.5 mul setlinewidth stroke
		setgray
	} if
	//tripleGauge trackType eq {
		gsave
			gsave
				trackWidth 4 mul setlinewidth stroke
			grestore
			currentgray 1 setgray
			trackWidth 2 mul setlinewidth stroke
			setgray
		grestore
		trackWidth setlinewidth stroke
	} if
	//quadGauge trackType eq {
		gsave
			gsave
				gsave
					trackWidth 5.5 mul setlinewidth stroke
				grestore
				currentgray 1 setgray
				trackWidth 3.5 mul setlinewidth stroke
				setgray
			grestore
			trackWidth 2.5 mul setlinewidth stroke
		grestore
		currentgray 1 setgray
		trackWidth 0.5 mul setlinewidth stroke
		setgray
	} if
	//thinGauge trackType eq {
		1 setlinewidth stroke
	} if
	setlinewidth
} def
/TunnelEntrance {
	gsave
		0.5 add -60 mul rotate
		0 hexHeight neg translate
		newpath
		1 setlinewidth
		0.5 setgray
		//trackWidth 4 div 0 //trackWidth 2 mul 0 90 arc
		//trackWidth 4 div neg 0 //trackWidth 2 mul 90 180 arc
		//trackWidth 4 div //trackWidth 4 mul moveto
		//trackWidth 4 div neg //trackWidth 4 mul lineto
		//trackWidth 2.25 mul neg 0 moveto
		//trackWidth 2.25 mul 0 lineto
		fill
	grestore
} def
/OffBoardTrack {
	gsave
		0.5 add -60 mul /trackRotation exch def
		trackRotation rotate
		0 hexHeight neg translate
		newpath
		//trackWidth 0.8 mul dup neg 0 moveto 0 lineto 0 //trackWidth 3 mul lineto
		closepath fill
	grestore
} def
/DividingLine {
	gsave
		-60 mul rotate
		newpath
		0 0 moveto
		0 hex_y0 rlineto
		1 setlinewidth
		stroke
	grestore
} def
/AppenninePass {
	gsave
		0.5 add -60 mul rotate
		1 setlinewidth
		newpath
		-6 0 moveto
		0 hexHeight 15 sub neg rlineto
		-5 -5 rlineto
		stroke
		newpath
		6 0 moveto
		0 hexHeight 15 sub neg rlineto
		5 -5 rlineto
		stroke
	grestore
} def
/SBahn {
	gsave
		0.5 add -60 mul rotate
		1 setlinewidth
		newpath
		-11 //stationRadius neg moveto
		5 -5 rlineto
		0 hexHeight 15 sub neg //stationRadius add rlineto
		-5 -5 rlineto
		stroke
		newpath
		11 //stationRadius neg moveto
		-5 -5 rlineto
		0 hexHeight 15 sub neg //stationRadius add rlineto
		5 -5 rlineto
		stroke
	grestore
} def
/AlpinePass {
	gsave
		0.5 add -60 mul rotate
		1 setlinewidth
		newpath
		-8 9 hexHeight sub moveto
		3 3 rlineto
		10 0 rlineto
		3 -3 rlineto
		stroke
		//trackWidth setlinewidth
		newpath
		0 hexHeight neg moveto
		0 12 rlineto
		stroke
	grestore
} def
/StraightTrack {
	gsave
		0.5 add -60 mul /trackRotation exch def
		trackRotation rotate
		newpath
		exch
		dup 0 gt {
			0 hexHeight neg moveto
			0 exch hexHeight 2 mul mul rlineto
		} {
			0 hexHeight moveto
			0 exch hexHeight 2 mul mul rlineto
		} ifelse
		StrokeTrack
		dup 0 eq {
			pop
		} {
			0 exch hexHeight 2 mul mul hexHeight sub translate
			/currentRotation currentRotation trackRotation add def
			Station
			/currentRotation currentRotation trackRotation sub def
		} ifelse
	grestore
} def
/WideTrack {
	gsave
		-60 mul /trackRotation exch def
		trackRotation rotate
		newpath
		/gaugeType exch def
		hexHeight -2 mul 0 hexSide 1.5 mul
		4 -1 roll dup 0 gt {
			-30 exch 60 mul -30 add
		} {
			60 mul 30 add 30
		} ifelse
		arc
		currentlinewidth
			trackWidth setlinewidth gaugeType StrokeTrack
		setlinewidth
		dup 0 eq {
			pop
		} {
			dup 0 lt { 1 add } if
			hexHeight -2 mul 0 translate
			60 mul -30 add dup rotate
			trackRotation add /trackRotation exch def
			/currentRotation currentRotation trackRotation add def
			hexSide 1.5 mul 0 translate
			Station
			/currentRotation currentRotation trackRotation sub def
		} ifelse
	grestore
} def
/SharpTrack {
	gsave
		1 add -60 mul /trackRotation exch def
		trackRotation rotate
		/gaugeType exch def
		newpath
		0 hexSide neg hexSide 0.5 mul
		4 -1 roll dup 0 gt {
			30 exch 120 mul 30 add
		} {
			120 mul 150 add 150
		} ifelse
		arc
		currentlinewidth
			trackWidth setlinewidth gaugeType StrokeTrack
		setlinewidth
		dup 0 eq {
			pop
		} {
			dup 0 lt { 1 add } if
			0 hexSide neg translate
			120 mul 30 add dup rotate
			trackRotation add /trackRotation exch def
			/currentRotation currentRotation trackRotation add def
			hexSide 0.5 mul 0 translate
			Station
			/currentRotation currentRotation trackRotation sub def
		} ifelse
	grestore
} def
/Station {
	dup () eq {
		pop
		newpath
		//trackWidth -1.5 mul dup 0 moveto
		neg 0 lineto
		currentlinewidth //trackWidth setlinewidth stroke setlinewidth
	} {
		dup (£) eq {
			pop
			newpath
			//trackWidth -1.5 mul dup 0 moveto
			neg 0 lineto
			currentgray
			0.5 setgray
			currentlinewidth //trackWidth setlinewidth stroke setlinewidth
			setgray
		} {
			gsave
				0 0 //stationRadius 0 360 arc
				gsave
					gsave 1 setgray fill grestore stroke
				grestore
				clip newpath
				currentRotation neg rotate
				dup (~) eq {
					3 setlinewidth
					//stationRadius 0.7 mul neg 0 moveto
					//stationRadius 0.7 mul 0 lineto stroke
				} {
					/Helvetica-Bold 13 selectfont
					0 0 3 -1 roll xycentershow
				} ifelse
			grestore
		} ifelse
	} ifelse
} def
/DoubleStation {
	gsave
		[ //stationRadius neg dup //stationRadius 2 mul dup ]
		dup currentgray exch 1 setgray rectfill setgray rectstroke
		//stationRadius 0 translate stationMarker Station
		//stationRadius 2 mul neg 0 translate stationMarker Station
	grestore
} def
/TripleInLineStation {
	gsave
		[ //stationRadius 2 mul neg //stationRadius -1 mul
		  //stationRadius 4 mul //stationRadius 2 mul ]
		dup currentgray exch 1 setgray rectfill setgray rectstroke
		//stationRadius 2 mul 0 translate stationMarker Station
		//stationRadius 2 mul neg 0 translate stationMarker Station
		//stationRadius 2 mul neg 0 translate stationMarker Station
	grestore
} def
/TripleStation {
	exch /r exch def
	{
		gsave
			30 rotate
			r 2 div //stationRadius add //hexHeight div dup scale
			TilePath gsave 1 setgray fill grestore stroke
		grestore
	} if
	gsave
		gsave -30 rotate r 0 translate 30 rotate stationMarker Station grestore
		gsave 0 r translate stationMarker Station grestore
		30 rotate r neg 0 translate -30 rotate stationMarker Station
	grestore
} def
/QuadrupleStation {
	gsave
		[ //stationRadius -1.7 mul dup //stationRadius 3.4 mul dup ]
		dup currentgray exch 1 setgray rectfill setgray rectstroke
		//stationRadius dup neg translate stationMarker Station
		//stationRadius 2 mul neg 0 translate stationMarker Station
		0 //stationRadius 2 mul translate stationMarker Station
		//stationRadius 2 mul 0 translate stationMarker Station
	grestore
} def
/QuintupleStation {
	gsave
		/sRad //stationRadius 36 sin div def
		/pRad sRad //stationRadius add def
		newpath
		pRad   0 cos mul pRad   0 sin mul moveto
		pRad  72 cos mul pRad  72 sin mul lineto
		pRad 144 cos mul pRad 144 sin mul lineto
		pRad 216 cos mul pRad 216 sin mul lineto
		pRad 288 cos mul pRad 288 sin mul lineto
		closepath
		gsave
			1 setgray fill
		grestore
		1 setlinewidth stroke
		sRad 0 cos mul sRad 0 sin mul translate stationMarker Station
		sRad 0 cos mul neg sRad 0 sin mul neg translate
		sRad 72 cos mul sRad 72 sin mul translate stationMarker Station
		sRad 72 cos mul neg sRad 72 sin mul neg translate
		sRad 144 cos mul sRad 144 sin mul translate stationMarker Station
		sRad 144 cos mul neg sRad 144 sin mul neg translate
		sRad 216 cos mul sRad 216 sin mul translate stationMarker Station
		sRad 216 cos mul neg sRad 216 sin mul neg translate
		sRad 288 cos mul sRad 288 sin mul translate stationMarker Station
		sRad 288 cos mul neg sRad 288 sin mul neg translate
	grestore
} def
/QuincunctialStation {
	gsave
		[ //stationRadius -3 mul 60 sin mul
		  //stationRadius -3 mul 60 cos mul
		  //stationRadius 6 mul 60 sin mul
  		  //stationRadius 6 mul 60 cos mul ]
		dup currentgray exch 1 setgray rectfill setgray rectstroke
		//stationRadius -2 mul 60 sin mul //stationRadius -2 mul 60 cos mul
		   	translate stationMarker Station
		//stationRadius 4 mul 60 sin mul 0
		   	translate stationMarker Station
		//stationRadius -2 mul 60 sin mul //stationRadius 2 mul 60 cos mul
		   	translate stationMarker Station
		//stationRadius -2 mul 60 sin mul //stationRadius 2 mul 60 cos mul
		   	translate stationMarker Station
		//stationRadius 4 mul 60 sin mul 0
		   	translate stationMarker Station
	grestore
} def
/SextupleStation {
	/size exch def
	gsave
		/sRad //stationRadius 30 sin div size div def
		/pRad sRad //stationRadius size div add def
		newpath
		pRad  30 cos mul pRad  30 sin mul moveto
		pRad  90 cos mul pRad  90 sin mul lineto
		pRad 150 cos mul pRad 150 sin mul lineto
		pRad 210 cos mul pRad 210 sin mul lineto
		pRad 270 cos mul pRad 270 sin mul lineto
		pRad 330 cos mul pRad 330 sin mul lineto
		closepath
		gsave
			1 setgray fill
		grestore
		1 setlinewidth stroke
		sRad 30 cos mul sRad 30 sin mul translate stationMarker Station
		sRad 30 cos mul neg sRad 30 sin mul neg translate
		sRad 90 cos mul sRad 90 sin mul translate stationMarker Station
		sRad 90 cos mul neg sRad 90 sin mul neg translate
		sRad 150 cos mul sRad 150 sin mul translate stationMarker Station
		sRad 150 cos mul neg sRad 150 sin mul neg translate
		sRad 210 cos mul sRad 210 sin mul translate stationMarker Station
		sRad 210 cos mul neg sRad 210 sin mul neg translate
		sRad 270 cos mul sRad 270 sin mul translate stationMarker Station
		sRad 270 cos mul neg sRad 270 sin mul neg translate
		sRad 330 cos mul sRad 330 sin mul translate stationMarker Station
		sRad 330 cos mul neg sRad 330 sin mul neg translate
	grestore
} def
/BridgedTripleStation {
	gsave
		newpath
			//stationRadius -1.25 mul //stationRadius moveto
			//stationRadius  1.25 mul //stationRadius 2 mul lineto
			//stationRadius  2.25 mul //stationRadius lineto
			//stationRadius  2.25 mul //stationRadius neg lineto
			//stationRadius  1.25 mul //stationRadius -2 mul lineto
			//stationRadius -1.25 mul //stationRadius neg lineto
		closepath
		gsave
			1 setgray fill
		grestore
		1 setlinewidth stroke
		//stationRadius 0.25 mul //stationRadius moveto
		//stationRadius 0.25 mul //stationRadius neg lineto
		stroke
		gsave
			//stationRadius -0.25 mul 0 moveto
			//stationRadius 0.25 mul 0 lineto
			//trackWidth setlinewidth stroke
		grestore
		//stationRadius 1.25 mul //stationRadius neg
			translate stationMarker Station
		0 //stationRadius 2 mul
			translate stationMarker Station
		//stationRadius -2.5 mul //stationRadius neg
			translate stationMarker Station
	grestore
} def
/stationMarker {
	dup mark eq { ( ) } if
} def
/SquareStation {
	gsave
		currentRotation neg rotate
		0.5 setlinewidth
		[ //stationRadius neg dup //stationRadius 2 mul dup ]
		dup dup currentgray exch 1 setgray rectfill setgray rectstroke
		rectclip
		/Helvetica-Bold 13 selectfont
		0 0 3 -1 roll xycentershow
	grestore
} def
/DoubleSquareStation {
	gsave
		//stationRadius 0 translate stationMarker SquareStation
		//stationRadius 2 mul neg 0 translate stationMarker SquareStation
	grestore
} def
/MixedStation {
	gsave
		currentRotation neg rotate
		0.5 setlinewidth
		[ //stationRadius neg dup //stationRadius 2 mul dup ]
		dup currentgray exch 1 setgray rectfill setgray rectstroke
		newpath
		//stationRadius 0 translate stationMarker SquareStation
		//stationRadius 2 mul neg 0 translate stationMarker Station
	grestore
} def
/DoubleDit {
	/r //trackWidth 0.8 mul def
	/rx r 1.2 mul def
	rx neg 0 rx 90 270 arc
	rx     0 rx 270 90 arc
	rx neg rx neg moveto
	rx rx neg lineto
	rx neg rx moveto
	rx rx lineto
	0.5 setlinewidth
	gsave
		tileColor
		haveColor {
			XcolorTable exch get
			aload pop
			setrgbcolor
		} {
			grayTable exch get
			setgray
		} ifelse
		fill
	grestore
	stroke
	gsave
		0 setgray
		rx neg 0 r 0 360 arc fill
		rx 0 r 0 360 arc fill
	grestore
} def
/TilePosition {
	exch dup 12 eq {
		pop pop
	} {
		dup 6 lt {
			/len //hexHeight def
		} {
			/len //hexSide def
		} ifelse
		dup 6 mod -60 mul exch 6 lt { -30 add } if
		/tpRotation exch def
		tpRotation rotate
		dup 0 lt {
			0 exch
		} {
			len neg exch add 0 exch
		} ifelse
		translate
		tpRotation neg rotate
	} ifelse
} def
/NameTilePosition {
	/tpWidth exch stringwidth pop 2 div def
	exch dup 12 eq {
		pop pop
	} {
		dup 6 lt {
			/len //hexHeight def
		} {
			/len //hexSide def
		} ifelse
		dup 6 mod 60 mul exch 6 lt { 30 add } if
		/tpRotation exch def
		dup 0 ge {
			len neg add
		} if
		dup
		tpRotation cos mul /tpY exch def
		tpRotation sin mul /tpX exch def
		/tpLeftR
			tpX tpWidth currentRotation neg cos mul sub dup mul
			tpY tpWidth currentRotation neg sin mul sub dup mul add sqrt
			//hexHeight 0.1 cm sub sub def
		/tpRightR
			tpX tpWidth currentRotation neg cos mul add dup mul
			tpY tpWidth currentRotation neg sin mul add dup mul add sqrt
			//hexHeight 0.1 cm sub sub def
		tpLeftR 0 gt
		{
			tpLeftR tpRightR neg gt
			{
				/tpX tpX tpLeftR tpRightR sub 2 div
					currentRotation neg cos mul add def
				/tpY tpY tpLeftR tpRightR sub 2 div
					currentRotation neg sin mul add def
			} {
				/tpX tpX tpLeftR currentRotation neg cos mul add def
				/tpY tpY tpLeftR currentRotation neg sin mul add def
			} ifelse
		} {
			tpRightR 0 gt
			{
				tpRightR tpLeftR neg gt
				{
					/tpX tpX tpLeftR tpRightR sub 2 div
						currentRotation neg cos mul add def
					/tpY tpY tpLeftR tpRightR sub 2 div
						currentRotation neg sin mul add def
				} {
					/tpX tpX tpRightR currentRotation neg cos mul sub def
					/tpY tpY tpRightR currentRotation neg sin mul sub def
				} ifelse
			} if
		} ifelse
		tpX tpY translate
	} ifelse
} def
/waterWidth 2.0 def
/Terrains [
	{ }
	{
		//waterWidth setlinewidth
		WaterPath stroke
	}
	{
		0 -0.1 cm translate
		//waterWidth setlinewidth
		WaterPath stroke
		0 0.2 cm translate
		WaterPath stroke
	}
	{
		//waterWidth setlinewidth
		WaterPath stroke
		0 -0.2 cm translate
		WaterPath stroke
		0 0.4 cm translate
		WaterPath stroke
	}
	{
		2.2 setlinewidth
		MountainPath stroke
	}
	{
		2.2 setlinewidth
		MountainPath stroke
		0.6 dup scale
		2.2 1 0.6 div mul setlinewidth
		MountainPath stroke
	}
	{
		2.2 setlinewidth
		HillPath stroke
	}
	{
		2.2 setlinewidth
		0 0.4 cm translate
		HillPath stroke
		//waterWidth setlinewidth
		0 -0.6 cm translate
		WaterPath stroke
	}
	{
		2.2 setlinewidth
		0 0.1 cm translate
		MountainPath stroke
		//waterWidth setlinewidth
		0 -0.6 cm translate
		WaterPath stroke
	}
	{
		//waterWidth setlinewidth
		WaterPath stroke
		0 -0.2 cm translate
		WaterPath stroke
		0 0.4 cm translate
		WaterPath stroke
		0 0.2 cm translate
		WaterPath stroke
	}
	{
		1 setlinewidth
		newpath
		0 0 stationRadius 0 360 arc stroke
		newpath
		-2.165 stationRadius mul -1.25 stationRadius mul moveto
		2.165 stationRadius mul -1.25 stationRadius mul lineto
		0 2.5 stationRadius mul lineto
		closepath stroke
	}
	{
		1 setlinewidth
		newpath
		0 0 stationRadius 0 360 arc stroke
		newpath
		-1.73 stationRadius mul -1 stationRadius mul moveto
		1.73 stationRadius mul -1 stationRadius mul lineto
		0 2 stationRadius mul lineto
		closepath stroke
	}
	{
		Anchor
	}
	{
		2 setlinewidth
		newpath
		stationRadius 2 div neg 0 moveto
		stationRadius 2 div 0 lineto stroke
		1 setlinewidth
		stationRadius 2 mul neg 0 stationRadius 1.5 mul 0 25 arc stroke
		stationRadius 2.75 mul neg 0 stationRadius 2.5 mul 0 20 arc stroke
		stationRadius 3.5 mul neg 0 stationRadius 3.5 mul 0 15 arc stroke
		stationRadius 3.5 mul 0 stationRadius 3.5 mul 165 180 arc stroke
		stationRadius 2.75 mul 0 stationRadius 2.5 mul 160 180 arc stroke
		stationRadius 2 mul 0 stationRadius 1.5 mul 155 180 arc stroke
	}
	{
		1 setlinewidth
		newpath
		stationRadius 10 div neg 0 moveto
		stationRadius 10 div 0 lineto
		0 stationRadius lineto
		closepath stroke
		0 stationRadius 1.35 mul stationRadius 0.35 mul 0 360 arc stroke
		stationRadius 0.3 mul neg
			stationRadius stationRadius 0.35 mul 0 360 arc stroke
		stationRadius 0.3 mul
			stationRadius stationRadius 0.35 mul 0 360 arc stroke
	}
	{
		0.5 setlinewidth
		newpath
		stationRadius 0.5 mul neg 0 moveto
		stationRadius 0.5 mul 0 lineto
		stationRadius 0.1 mul neg 0 moveto
		stationRadius 0.1 mul neg stationRadius 1.5 mul lineto
		stationRadius 0.1 mul 0 moveto
		stationRadius 0.1 mul stationRadius 1.5 mul lineto
		0 stationRadius 1.5 mul stationRadius 0.1 mul 0 180 arc stroke
		stationRadius 0.2 mul neg stationRadius 0.7 mul moveto
		stationRadius 0.1 mul neg stationRadius 0.7 mul lineto
		stationRadius 0.2 mul neg stationRadius 0.8 mul moveto
		stationRadius 0.1 mul neg stationRadius 0.8 mul lineto
		stationRadius 0.3 mul neg stationRadius 0.8 mul moveto
		stationRadius 0.3 mul neg stationRadius 1.1 mul lineto
		stationRadius 0.2 mul neg stationRadius 0.8 mul moveto
		stationRadius 0.2 mul neg stationRadius 1.1 mul lineto
		stationRadius 0.25 mul neg stationRadius 1.1 mul
			stationRadius 0.05 mul 0 180 arc stroke
		stationRadius 0.2 mul neg stationRadius 0.8 mul
			stationRadius 0.1 mul 180 270 arc stroke
		stationRadius 0.2 mul stationRadius 0.75 mul moveto
		stationRadius 0.1 mul stationRadius 0.75 mul lineto
		stationRadius 0.2 mul stationRadius 0.85 mul moveto
		stationRadius 0.1 mul stationRadius 0.85 mul lineto
		stationRadius 0.3 mul stationRadius 0.85 mul moveto
		stationRadius 0.3 mul stationRadius 1.15 mul lineto
		stationRadius 0.2 mul stationRadius 0.85 mul moveto
		stationRadius 0.2 mul stationRadius 1.15 mul lineto
		stationRadius 0.25 mul stationRadius 1.15 mul
			stationRadius 0.05 mul 0 180 arc stroke
		stationRadius 0.2 mul stationRadius 0.85 mul
			stationRadius 0.1 mul 270 0 arc stroke
	}
	{
		Anchor
		gsave
			stationRadius 0.5 mul dup neg translate
			Anchor
		grestore
	}
	{
		1 setlinewidth
		currentRotation rotate
		-0.5 cm 0.5 cm translate
		newpath
		0 0 moveto
		//stationRadius 2 div //stationRadius 1.8 mul lineto
		stroke
		0 0 //trackWidth 1 sub 0 360 arc gsave 1 setgray fill grestore stroke
		//stationRadius 2 div //stationRadius 1.8 mul
		//trackWidth 1 sub 0 360 arc gsave 1 setgray fill grestore stroke
		0.5 cm -0.5 cm translate
		currentRotation neg rotate
	}
	{
		gsave
		pickWidth setlinewidth
		//pickY 2 mul dup //pickX neg dup
		moveto rlineto stroke
		//pickY 2 mul dup neg exch //pickX pickX neg
		moveto rlineto stroke
		//pickTopX //pickTopY moveto
		//pickTopOrig neg dup
		//pickTopOrig //pickTopX add dup mul
		//pickTopOrig //pickTopY add dup mul
		add sqrt 20 70 arc
		stroke
		//pickTopX neg //pickTopY moveto
		//pickTopOrig dup neg
		//pickTopOrig //pickTopX add dup mul
		//pickTopOrig //pickTopY add dup mul
		add sqrt 160 110 arcn
		stroke
		grestore
	}
	{
		2.2 setlinewidth
		MountainPath stroke
		0.6 dup scale
		2.2 1 0.6 div mul setlinewidth
		MountainPath stroke
		0.6 dup scale
		2.2 1 0.6 div dup mul mul setlinewidth
		MountainPath stroke
	}
] def
/HexTerrain {
	gsave
		3 1 roll
		TilePosition
		currentRotation neg rotate
		dup scale
		Terrains exch get exec
	grestore
} def
/NoTerrain {
	pop
} def
/HexBox {
	/val exch stringwidth pop def
	0.5 setlinewidth
	[ val 2 div 0.1 cm add neg
	  mineBoxY neg 0.1 cm add
	  val 0.2 cm add
	  mineBoxY 1.7 mul
	] dup
	1 setgray rectfill
	0 setgray rectstroke
} def
/HexValue {
	3 -1 roll /hexVal exch def
	hexVal () eq {
		pop pop
	} {
		gsave
			TilePosition
			currentRotation neg rotate
			valFont selectfont
			hexVal (/) search {
				pop pop pop
				hexVal HexBox
			} {
				(\() search {
					pop pop pop
				} {
					([) search {
						pop pop pop
						hexVal ([) anchorsearch
						pop pop
						/hexVal exch def
						hexVal HexBox
					} {
						({) search {
							pop pop pop
							hexVal ({) anchorsearch
							pop pop
							/hexVal exch def
							hexVal HexPentagon
						} {
							pop
							hexVal length 2 gt {
								//valRadius 2 div neg 0
									//valRadius 90 270 arc
								//valRadius 2 div 0
									//valRadius 270 90 arc
								//valRadius 2 div neg
									//valRadius neg moveto
								//valRadius 2 div
									//valRadius neg lineto
								//valRadius 2 div neg
									//valRadius moveto
								//valRadius 2 div
									//valRadius lineto
							} {
								0 0 //valRadius 0 360 arc
							} ifelse
							0.5 setlinewidth
							gsave
								1 setgray fill
							grestore
							stroke
						} ifelse
					} ifelse
				} ifelse
			} ifelse
			0 -0.1 cm hexVal centershow
		grestore
	} ifelse
} def
/NoValue {
	pop
} def
/HexDiamond {
	0.5 setlinewidth
	newpath
	dup length 2 gt {
		/w exch stringwidth pop 2 div def
		w neg //valRadius 0.75 mul sub 0 moveto
		w neg //valRadius 0.25 mul add //valRadius lineto
		w //valRadius 0.25 mul sub //valRadius lineto
		w //valRadius 0.75 mul add 0 lineto
		w //valRadius 0.25 mul sub //valRadius neg lineto
		w neg //valRadius 0.25 mul add //valRadius neg lineto
		w neg //valRadius 0.75 mul sub 0 lineto
	} {
		pop
		//valRadius 1.5 mul neg 0 moveto
		0 //valRadius 1.5 mul lineto
		//valRadius 1.5 mul 0 lineto
		0 //valRadius 1.5 mul neg lineto
		//valRadius 1.5 mul neg 0 lineto
	} ifelse
	gsave
		1 setgray fill
	grestore
	stroke
} def
/HexPentagon {
	/w exch stringwidth pop 2 div //valRadius sub def
	w 0 le {
		 /w 0 def
	} if
	newpath
	//valRadius 36 cos div  90 cos mul w add
	//valRadius 36 cos div  90 sin mul moveto
	//valRadius 36 cos div  90 cos mul w sub
	//valRadius 36 cos div  90 sin mul lineto
	//valRadius 36 cos div 162 cos mul w sub
	//valRadius 36 cos div 162 sin mul lineto
	//valRadius 36 cos div 234 cos mul w sub
	//valRadius 36 cos div 234 sin mul lineto
	//valRadius 36 cos div 306 cos mul w add
	//valRadius 36 cos div 306 sin mul lineto
	//valRadius 36 cos div  18 cos mul w add
	//valRadius 36 cos div  18 sin mul lineto
	closepath
	gsave
		1 setgray fill
	grestore
	0.5 setlinewidth stroke
} def
/HexLabel {
	3 -1 roll /hexLabel exch def
	hexLabel () eq {
		pop pop
	} {
		hexLabel (@) anchorsearch {
			pop
			/hexLabel exch def
			gsave
				TilePosition
				currentRotation neg rotate
				/Helvetica-Bold 12 selectfont
				hexLabel HexDiamond
				0 0 hexLabel xycentershow
			grestore
		} {
			pop
			hexLabel ([) anchorsearch {
				pop
				/hexLabel exch def
				gsave
					TilePosition
					currentRotation neg rotate
					/Helvetica-Bold 12 selectfont
					hexLabel HexBox
					0 0 hexLabel xycentershow
				grestore
			} {
				pop
				gsave
					TilePosition
					currentRotation neg rotate
					/Helvetica-Bold 12 selectfont
					0 -0.1 cm hexLabel centershow
				grestore
			} ifelse
		} ifelse
	} ifelse
} def
/NoLabel {
	pop
} def
/HexName {
	3 -1 roll /hexName exch def
	hexName mark eq {
		pop pop mark
	} {
		hexName (#) anchorsearch {
			pop
			/hexName exch def
			gsave
				/Helvetica 10 selectfont
				hexName NameTilePosition
				currentRotation neg rotate
				0 -0.1 cm hexName centershow
			grestore
		} {
			pop pop pop hexName
		} ifelse
	} ifelse
} def
/NoName {
	dup mark ne {
		(#) anchorsearch {
			pop pop
		} if
	} if
} def
/mineRect {
	gsave
		/mineDist exch def
		/minePos exch def
		minePos mineDist TilePosition
		1 setgray
		currentRotation neg rotate
		[ //mineSize neg dup //mineSize 2 mul dup ]
		dup 1 setgray rectfill 0 setgray rectstroke
		pickWidth setlinewidth
		//pickY 2 mul dup //pickX neg dup
		moveto rlineto stroke
		//pickY 2 mul dup neg exch //pickX pickX neg
		moveto rlineto stroke
		//pickTopX //pickTopY moveto
		//pickTopOrig neg dup
		//pickTopOrig //pickTopX add dup mul
		//pickTopOrig //pickTopY add dup mul
		add sqrt 20 70 arc
		stroke
		//pickTopX neg //pickTopY moveto
		//pickTopOrig dup neg
		//pickTopOrig //pickTopX add dup mul
		//pickTopOrig //pickTopY add dup mul
		add sqrt 160 110 arcn
		stroke
	grestore
} def
/MineValue {
	3 -1 roll /mineVal exch def
	mineVal () eq {
		pop pop
	} {
		gsave
			TilePosition
			currentRotation neg rotate
			mineVal (/) search {
				pop pop pop
				0.5 setlinewidth
				[ //mineBoxX neg mineBoxY neg 0.1 cm add
				  //mineBoxX 2 mul mineBoxY 1.7 mul
				] dup
				1 setgray rectfill
				0 setgray rectstroke
			} {
				(\() search {
					pop pop pop
				} {
					pop
					0 0 //valRadius 0 360 arc
					0.5 setlinewidth
					gsave
						1 setgray fill
					grestore
					stroke
				} ifelse
			} ifelse
			/Helvetica 14 selectfont
			0 -0.1 cm mineVal centershow
		grestore
	} ifelse
} def
/MineLabel {
	3 -1 roll /mineLabel exch def
	mineLabel () eq {
		pop pop
	} {
	gsave
		TilePosition
		18xxVariant (none) eq { 0 setgray } { 1 setgray } ifelse
		currentRotation neg rotate
		/Helvetica-Bold 14 selectfont
		0 -0.1 cm mineLabel centershow
	grestore
	} ifelse
} def
/passDraw {
	gsave
		/passDist exch def
		/passPos exch def
		passPos passDist TilePosition
		0 0 moveto
		0 setgray
		1 setlinewidth
		4.5 -4.5 lineto 21 0 rlineto
		4.5 4.5 rlineto -1.8 1.8 rlineto
		-3.5 -3.5 rlineto -19.2 0 rlineto
		-3.5 3.5 rlineto
		closepath stroke
		0 -15.5 moveto
		4.5 4.5 rlineto 21 0 rlineto
		4.5 -4.5 rlineto -1.8 -1.8 rlineto
		-3.5 3.5 rlineto -19.2 0 rlineto
		-3.5 -3.5 rlineto
		closepath stroke
		-15 0 moveto
		2 setlinewidth
		14 -4.5 rlineto stroke
		1 setlinewidth 1 setgray
		-11 0 moveto
		-15 0 4 0 360 arc fill
		0 setgray
		-15 0 4 0 360 arc stroke
		45 -15.5 moveto
		2 setlinewidth
		-14 4.5 rlineto stroke
		1 setlinewidth 1 setgray
		41 -15.5 moveto
		45 -15.5 4 0 360 arc fill
		0 setgray
		45 -15.5 4 0 360 arc stroke
	grestore
} def
/StraightBridge {
	gsave
		TilePosition
		-60 mul rotate
		/bridgeOffset exch def
		tileColor
		haveColor {
			XcolorTable exch get
			aload pop
			setrgbcolor
		} {
			grayTable exch get
			setgray
		} ifelse
		[ -7 -4.5 14 9.1 ] rectfill
		0 setgray 1 setlinewidth
		-10 bridgeOffset sub -8.5 moveto
		3.5 3.5 rlineto 14 0 rlineto 3.5 -3.5 rlineto stroke
		-10 bridgeOffset add 9.0 moveto
		3.5 -3.5 rlineto 14 0 rlineto 3.5 3.5 rlineto stroke
	grestore
} def
/WideBridge {
	gsave
		-60 mul rotate
		tileColor
		haveColor {
			XcolorTable exch get
			aload pop
			setrgbcolor
		} {
			grayTable exch get
			setgray
		} ifelse
		/startAngle exch def /stopAngle exch def
		newpath
		hexHeight -2 mul 0 hexSide 1.42 mul
		startAngle stopAngle arc
		hexHeight -2 mul 0 hexSide 1.58 mul
		stopAngle startAngle arcn closepath fill
		0 setgray 1 setlinewidth
		startAngle 3 sub cos hexSide 1.35 mul mul hexHeight -2 mul add
		startAngle 3 sub sin hexSide 1.35 mul mul moveto
		hexHeight -2 mul 0 hexSide 1.41 mul
		startAngle stopAngle arc
		stopAngle 3 add cos hexSide 1.35 mul mul hexHeight -2 mul add
		stopAngle 3 add sin hexSide 1.35 mul mul lineto
		stroke
		stopAngle 2 add cos hexSide 1.65 mul mul hexHeight -2 mul add
		stopAngle 2 add sin hexSide 1.65 mul mul moveto
		hexHeight -2 mul 0 hexSide 1.59 mul
		stopAngle startAngle arcn
		startAngle 2 sub cos hexSide 1.65 mul mul hexHeight -2 mul add
		startAngle 2 sub sin hexSide 1.65 mul mul lineto
		stroke
	grestore
} def
/currentRotation 0 def
/TileProcName (Tile_xxx) def
/TileProc {
	abs
	TileProcName 5 (000) putinterval
	TileProcName exch string5 cvs dup length 8 exch sub exch putinterval
	TileProcName cvx dup where {
				pop
			} {
				pop (Tile_000) cvx
			} ifelse
} def
/HexPos {
	toupper
	(/) search pop exch pop
	/s exch def
	/numStart 1 def
	s 0 get 64 sub
	s 1 get 64 sub dup 0 ge exch 26 lt and {
		/numStart 2 def
		//useSexavigenary {
			26 mul s 1 get 64 sub add
		} {
			26 add
		} ifelse
	} if
	axesSwapped {
		axisDirection //axisLetBack eq axisDirection //axisBothBack eq or {
			mapCols 1 add sub neg
		} if
	} {
		axisDirection //axisNumBack eq axisDirection //axisBothBack eq or {
			mapRows 1 add sub neg
		} if
	} ifelse
	s numStart s length numStart sub getinterval cvi
	axesSwapped {
		axisDirection //axisNumBack eq axisDirection //axisBothBack eq or {
			mapRows 1 add sub neg
		} if
	} {
		axisDirection //axisLetBack eq axisDirection //axisBothBack eq or {
			mapCols 1 add sub neg
		} if
	} ifelse
	axesSwapped {
		exch
	} if
	3 -1 roll
	/s exch def
	tileSitting {
		/oos [(S) (SW) (NW) (N) (NE) (SE) (0) (1) (2) (3) (4) (5)] def
	} {
		/oos [(SW) (W) (NW) (NE) (E) (SE) (0) (1) (2) (3) (4) (5)] def
	} ifelse
	0 1 11 {
		dup
		oos exch get s eq
		{ 6 mod exit } { pop } ifelse
	} for
} def
/XYTileDict 30 dict def
/XYTile {
	XYTileDict begin
	gsave
		11 -2 roll
		translate
		tileSitting {
			30 rotate
			/currentRotation currentRotation 30 add def
		} if
		9 -5 roll
		/hexColor exch def
		hexColor tlNoHex ne {
			hexColor TileColor
		} if
		TilePath
		clip
		newpath
		gsave
			-60 mul /xyTileRotation exch def
			xyTileRotation rotate
			dup 0 le {
				pop
			} {
				TileNumber
			} ifelse
			-60 mul dup
			rotate
			/xyTileRotation exch xyTileRotation add def
			/currentRotation currentRotation xyTileRotation add def
			/num exch def
			dup length /len exch def mark exch aload pop
			len 4 add -3 roll exch 3 -1 roll
			num TileProc exec
			cleartomark
			/currentRotation currentRotation xyTileRotation sub def
		grestore
		hexColor tlNoHex ne
		hexColor tlTransparent ne and {
			TilePath stroke
		} if
		tileSitting {
			/currentRotation currentRotation 30 sub def
		} if
	grestore
	end
} def
/VariantToGeneric {
	exch dup
	/tile tileCodes 3 -1 roll abs get def
	exch
	tile null eq {
		0 0 4 2 roll //tlGround //tlPlain () ()
	} {
		tile 0 6 getinterval aload pop
		8 -2 roll
		6 2 roll
	} ifelse
} def
/nColours 13 def
/TileAvailability {
	/numPages exch def
	/page exch def
	/gStart page tileSitting {10}{9} ifelse mul def
	/listScale 0.6 def
	gsave
	listScale dup scale
	/CM { 28.35 1 listScale div mul mul } def
	/Helvetica-Bold 24 selectfont
	2 CM //hexHeight sub 27 CM moveto
	/quantity 4 string def
	(Tile Availability: ) show 18xxVariant show
	numPages 1 gt {
		( Page ) show
		page 1 add quantity cvs show
		( of ) show
		numPages quantity cvs show
	} if
	/x 2 CM def
	/y 27 CM tileSitting {//hexHeight}{//hexSide} ifelse 0.8 CM add sub def
	/row 0 def
	/col 0 def
	/xdist tileSitting {//hexSide}{//hexHeight} ifelse 2 mul 0.15 cm add def
	/ydist tileSitting {//hexHeight}{//hexSide} ifelse 2 mul 0.5 cm add def
	/Helvetica 15 selectfont
	0 1 nColours {
		/color exch def
		/legendx x xdist col mul add
			tileSitting {//hexSide}{//hexHeight} ifelse sub def
		/legendy y ydist row gStart sub mul sub
			tileSitting {//hexHeight}{//hexSide} ifelse 1.25 mul add def
		/count 0 def
		0 1 maxTile 1 sub {
			/vnum exch def
			tileCodes vnum get /tile exch def
			tile null ne {
				tile 6 get 0 gt
				tile 2 get color eq and {
					row gStart ge
					row tileSitting {9}{8} ifelse gStart add le and {
						/count count 1 add def
						x xdist col mul add
						y ydist row gStart sub mul sub
						2 copy
						2 copy
						vnum 0 VariantToGeneric
						[] XYTile
						exch tileSitting {//hexSide}{//hexHeight} ifelse add
						exch tileSitting {//hexHeight}{//hexSide} ifelse sub
						/Helvetica 15 selectfont
						tile 6 get quantity cvs rightshow
						exch tileSitting {//hexSide}{//hexHeight} ifelse sub
						exch tileSitting {//hexHeight}{//hexSide} ifelse sub
						moveto tile 7 get quantity cvs show
					} if
					col tileSitting {7}{8} ifelse eq {
						/col 0 def /row row 1 add def
					} {
						/col col 1 add def
					} ifelse
				} if
			} if
		} for
		col 0 ne { /col 0 def /row row 1 add def} if
		count 0 ne {
			legendx legendy moveto
			/Helvetica-Bold 18 selectfont
			ColorNameTable color get show
			/y y 0.3 CM sub def
		} if
	} for
	grestore
} def
/VariantTileAvailability {
	/nRows exch def
	/numPages exch def
	/page exch def
	/gStart page nRows mul def
	/listScale 0.8 nRows div def
	gsave
	/CM { 28.35 1 listScale div mul mul } def
	/Helvetica-Bold 16 selectfont
	2 CM //hexHeight sub 27 cm moveto
	/quantity 4 string def
	(Tile Availability: ) show 18xxVariant show
	numPages 1 gt {
		( Page ) show
		page 1 add quantity cvs show
		( of ) show
		numPages quantity cvs show
	} if
	listScale dup scale
	/xsize tileSitting {//hexSide}{//hexHeight} ifelse def
	/ysize tileSitting {//hexHeight}{//hexSide} ifelse def
	/x 2 CM def
	/y 27 CM ysize 0.8 CM add sub def
	/row 0 def
	/col 0 def
	/xdist xsize 2 mul 0.15 cm add def
	/ydist ysize 2 mul 0.5 cm add def
	0 1 nColours {
		/color exch def
		/count 0 def
		0 1 maxTile 1 sub {
			/vnum exch def
			tileCodes vnum get /tile exch def
			tile null ne {
				tile 6 get 0 gt
				tile 2 get color eq and {
					row gStart ge
					row nRows gStart add lt and {
						col 0 eq {
							0 1 5 {
								/myorient exch 1 add def
								x
								y ydist 7 mul 1 cm add row gStart sub mul sub
								ydist myorient mul sub
								2 copy
								translate
								tileSitting {
									30 rotate
								} if
								TilePath stroke
								tileSitting {
									-30 rotate
								} if
								1 setlinewidth
								xsize neg 2 div 0 moveto
								xsize 2 div 0 lineto stroke
								/Helvetica 30 selectfont
								0 0 moveto
								0 0.3 cm
									orientNumbers
										{ myorient quantity cvs } { (?) }
										ifelse
										centershow
								0 -1 cm
								tileSitting {
									[(NW) (N) (NE) (SE) (S) (SW)]
								}{
									[(NW) (NE) (E) (SE) (SW) (W)]
								} ifelse
								myorient 1 sub get centershow
								neg exch neg exch translate
							} for
						} if
						x xdist col 1 add mul add
						y ydist 7 mul 1 cm add row gStart sub mul sub
						count 0 eq col 0 eq or {
							2 copy
							exch tileSitting {//hexSide}{//hexHeight} ifelse
								sub
							exch tileSitting {//hexHeight}{//hexSide} ifelse
								1.25 mul add
							moveto
							/Helvetica-Bold 12 nRows mul selectfont
							ColorNameTable color get show
						} if
						/count count 1 add def
						2 copy
						2 copy
						translate
						tileSitting {
							30 rotate
						} if
						TilePath stroke
						tileSitting {
							-30 rotate
						} if
						1 setlinewidth
						xsize neg 2 div 0 moveto
						xsize 2 div 0 lineto stroke
						/Helvetica 30 selectfont
						0 0 moveto
						0 0.3 cm tile 7 get quantity cvs centershow
						xsize ysize 0.6 cm add neg
						tile 6 get quantity cvs rightshow
						tile 5 get () ne {
							0 -1 cm tile 5 get centershow
						} if
						neg exch neg exch translate
						2 copy
						2 copy
						2 copy
						2 copy
						2 copy
						0 1 5 {
							/myorient exch def
							ydist myorient 1 add mul sub
							vnum myorient 2 add 6 mod VariantToGeneric
							[] XYTile
						} for
					} if
					x xdist col 2 add mul add 19.5 CM gt {
						/col 0 def /row row 1 add def
					} {
						/col col 1 add def
					} ifelse
				} if
			} if
		} for
	} for
	grestore
} def
/cuttingTileAvailability {
	/numPages exch def
	/page exch def
	/tStart page 25 mul def
	/listScale 1.15 def
        /tileSitting false def
	gsave
	listScale dup scale
	/CM { 28.35 1 listScale div mul mul } def
	/Helvetica-Bold 24 selectfont
	2 CM //hexHeight 2 div sub 27 CM moveto
	/quantity 4 string def
	(Tile Sheet: ) show 18xxVariant show
	numPages 1 gt {
		( Page ) show
		page 1 add quantity cvs show
		( of ) show
		numPages quantity cvs show
	} if
	/x 2 CM //hexHeight 2 div add def
	/y 27.5 CM //hexSide 0.8 CM add sub def
	/row 0 def
	/col 0 def
	/xdist //hexHeight 2 mul def
	/ydist //hexSide 2 mul def
	/Helvetica 15 selectfont
	/count 0 def
	0 1 nColours {
		/color exch def
		0 1 maxTile 1 sub {
			/vnum exch def
			tileCodes vnum get /tile exch def
			tile null ne {
				tile 6 get 0 gt
				tile 2 get color eq and {
					1 1 tile 6 get {
						count tStart ge count tStart 25 add lt and {
							x xdist col mul add
							y ydist row mul sub
							col 2 mod 0 ne {
								ydist 2 div sub
							} if
							2 copy
							translate
							0 0
							tileSitting {
								-30 rotate
							} if
							vnum 0 VariantToGeneric
							[] XYTile
							tileSitting {
								30 rotate
							} if
							neg exch neg exch
							translate
							col 4 eq {
								/col 0 def /row row 1 add def
							} {
								/col col 1 add def
								row 5 eq col 2 mod 0 ne and {
									/col col 1 add def
								} if
							} ifelse
						} if
						/count count 1 add def
					} for
				} if
			} if
		} for
	} for
	grestore
} def
/18xxVariant (18pa) def
/maxTile 34 def
	/tileCodes //maxTile array def
tileCodes 1 [ 3 1 //tlYellow //tlPlain () (10) 3 (3) ] put
tileCodes 2 [ 4 0 //tlYellow //tlPlain () (10) 5 (4) ] put
tileCodes 3 [ 6 0 //tlYellow //tlPlain () (20) 6 (6) ] put
tileCodes 4 [ 7 0 //tlYellow //tlPlain () () 3 (7) ] put
tileCodes 5 [ 8 0 //tlYellow //tlPlain () () 8 (8) ] put
tileCodes 6 [ 9 0 //tlYellow //tlPlain () () 8 (9) ] put
tileCodes 7 [ 14 0 //tlGreen //tlPlain () (30) 2 (14) ] put
tileCodes 8 [ 15 0 //tlGreen //tlPlain () (30) 2 (15) ] put
tileCodes 9 [ 23 0 //tlGreen //tlPlain () () 3 (23) ] put
tileCodes 10 [ 24 0 //tlGreen //tlPlain () () 3 (24) ] put
tileCodes 11 [ 26 0 //tlGreen //tlPlain () () 2 (26) ] put
tileCodes 12 [ 27 0 //tlGreen //tlPlain () () 2 (27) ] put
tileCodes 13 [ 57 0 //tlYellow //tlPlain () (20) 6 (57) ] put
tileCodes 14 [ 58 0 //tlYellow //tlPlain () (10) 5 (58) ] put
tileCodes 15 [ 141 0 //tlGreen //tlPlain () (10) 3 (141) ] put
tileCodes 16 [ 142 0 //tlGreen //tlPlain () (10) 3 (142) ] put
tileCodes 17 [ 51 4 //tlBrown //tlPlain () (40) 3 (216) ] put
tileCodes 18 [ 505 0 //tlRed //tlPlain () (0/20/30) 0 (401) ] put
tileCodes 19 [ 506 0 //tlRed //tlPlain () (0/20/30) 0 (402) ] put
tileCodes 20 [ 505 0 //tlGray //tlPlain () (0/20/30) 0 (403) ] put
tileCodes 21 [ 506 0 //tlGray //tlPlain () (0/20/30) 0 (404) ] put
tileCodes 22 [ 500 1 //tlBlue //tlPlain (W 80) () 0 (409) ] put
tileCodes 23 [ 500 0 //tlGround //tlPlain () () 0 (410) ] put
tileCodes 24 [ 246 1 //tlGround //tlPlain () () 0 (420) ] put
tileCodes 25 [ 242 3 //tlGround //tlPlain () () 0 (430) ] put
tileCodes 26 [ 242 3 //tlGround //tlPlain (R) () 0 (431) ] put
tileCodes 27 [ 239 0 //tlBrown //tlPlain (R) (50) 1 (r239) ] put
tileCodes 28 [ 4 0 //tlYellow //tlPlain (R) (30) 1 (r4) ] put
tileCodes 29 [ 58 0 //tlYellow //tlPlain (R) (30) 1 (r58) ] put
tileCodes 30 [ 87 0 //tlGreen //tlPlain (R) (40) 1 (r87) ] put
tileCodes 31 [ 88 0 //tlGreen //tlPlain (R) (40) 1 (r88) ] put
tileCodes 32 [ 8 0 //tlYellow //tlPlain (W) () 2 (w8) ] put
tileCodes 33 [ 9 0 //tlYellow //tlPlain (W) () 3 (w9) ] put
/Tile_000 {
	6 -0.8 cm 1 HexTerrain 11 //labCDist HexLabel 9 //valCDist HexValue
	NoName
	gsave
		/Helvetica 15 selectfont
		currentRotation neg rotate
		0 0 (undefined) centershow
	grestore
} def
/Tile_003 {
	NoTerrain 5 //labEDist HexLabel 8 //valADist HexValue NoName
	() 0.5 1 //stdGauge //orSouthWest SharpTrack
} def
/Tile_004 {
	2 0.5 cm 1 HexTerrain 5 //labEDist HexLabel 4 //valEDist HexValue NoName
	() 0.5 1 //stdGauge //orSouthWest StraightTrack
} def
/Tile_006 {
	1 0.5 cm 1 HexTerrain 5 //labEDist HexLabel 3 //valEDist HexValue
	2 //labCDist HexName
	//noStation 0.5 //stdGauge //orEast StraightTrack
	stationMarker 0.5 0.5 //stdGauge //orSouthWest StraightTrack
} def
/Tile_007 {
	NoTerrain 2 //labEDist HexLabel NoValue NoName
	//noStation 1 //stdGauge //orSouthWest SharpTrack
} def
/Tile_008 {
	4 0.5 cm 1 HexTerrain 1 //labEDist HexLabel NoValue NoName
	//noStation 1 //stdGauge //orSouthWest WideTrack
} def
/Tile_009 {
	1 0.5 cm 1 HexTerrain 1 //labEDist HexLabel NoValue NoName
	//noStation 1 //stdGauge //orSouthWest StraightTrack
} def
/Tile_014 {
	11 0.5 cm 0.6 HexTerrain 8 //labCDist HexLabel 9 //valCDist HexValue
	11 0.3 cm HexName
	//noStation 1 //stdGauge //orSouthWest StraightTrack
	//noStation 1 //stdGauge //orNorthWest StraightTrack
	DoubleStation
} def
/Tile_015 {
	6 0.7 cm 0.6 HexTerrain 7 //labCDist HexLabel 10 //valCDist HexValue NoName
	//noStation 1 //stdGauge //orSouthWest StraightTrack
	//noStation 0.5 //stdGauge //orWest StraightTrack
	//noStation 0.5 //stdGauge //orNorthWest StraightTrack
	/currentRotation currentRotation -30 add def
	-30 rotate
	DoubleStation
	/currentRotation currentRotation -30 sub def
} def
/Tile_023 {
	NoTerrain NoLabel NoValue NoName
	//noStation 1 //stdGauge //orSouthWest StraightTrack
	//noStation 1 //stdGauge //orEast WideTrack
} def
/Tile_024 {
	NoTerrain NoLabel NoValue NoName
	//noStation 1 //stdGauge //orSouthWest StraightTrack
	//noStation 1 //stdGauge //orSouthWest WideTrack
} def
/Tile_026 {
	NoTerrain NoLabel NoValue NoName
	//noStation 1 //stdGauge //orSouthWest StraightTrack
	//noStation 1 //stdGauge //orSouthEast SharpTrack
} def
/Tile_027 {
	NoTerrain NoLabel NoValue NoName
	//noStation 1 //stdGauge //orSouthWest StraightTrack
	//noStation 1 //stdGauge //orSouthWest SharpTrack
} def
/Tile_051 {
	NoTerrain 7 //labCDist HexLabel 3 //valEDist HexValue NoName
	//noStation 1 //stdGauge //orEast StraightTrack
	//noStation 1 //stdGauge //orNorthWest StraightTrack
	//noStation 0.5 //stdGauge //orSouthWest StraightTrack
	/currentRotation currentRotation -30 add def
	-30 rotate
	DoubleStation
	/currentRotation currentRotation -30 sub def
} def
/Tile_057 {
	1 0.5 cm 1 HexTerrain 5 //labEDist HexLabel 4 //valEDist HexValue 2 //labEDist HexName
	stationMarker 0.5 1 //stdGauge //orSouthWest StraightTrack
} def
/Tile_058 {
	NoTerrain 1 //labEDist HexLabel 3 //valEDist HexValue 5 //valEDist HexName
	() 0.5 1 //stdGauge //orSouthWest WideTrack
} def
/Tile_087 {
	NoTerrain 7 //labCDist HexLabel 4 //valEDist HexValue NoName
	//noStation 0.5 //stdGauge //orWest StraightTrack
	//noStation 0.5 //stdGauge //orNorthWest StraightTrack
	//noStation 1 //stdGauge //orSouthWest StraightTrack
	0 0 //trackWidth 0 360 arc gsave 1 setgray fill grestore stroke
	0 0 //trackWidth 0.6 mul 0 360 arc fill
} def
/Tile_088 {
	NoTerrain 7 //labCDist HexLabel 4 //valEDist HexValue NoName
	//noStation 1 //stdGauge //orNorthWest StraightTrack
	//noStation 1 //stdGauge //orSouthWest StraightTrack
	0 0 //trackWidth 0 360 arc gsave 1 setgray fill grestore stroke
	0 0 //trackWidth 0.6 mul 0 360 arc fill
} def
/Tile_141 {
	NoTerrain 7 //labCDist HexLabel 2 //valEDist HexValue 1 //labADist HexName
	//noStation 0.5 //stdGauge //orEast StraightTrack
	//noStation 1 //stdGauge //orSouthWest StraightTrack
	0 0 //trackWidth 0 360 arc gsave 1 setgray fill grestore stroke
	0 0 //trackWidth 0.6 mul 0 360 arc fill
} def
/Tile_142 {
	NoTerrain 7 //labCDist HexLabel 4 //valEDist HexValue NoName
	//noStation 0.5 //stdGauge //orNorthWest StraightTrack
	//noStation 1 //stdGauge //orSouthWest StraightTrack
	0 0 //trackWidth 0 360 arc gsave 1 setgray fill grestore stroke
	0 0 //trackWidth 0.6 mul 0 360 arc fill
} def
/Tile_239 {
	NoTerrain 7 //labCDist HexLabel 10 //valEDist HexValue NoName
	//noStation 1 //stdGauge //orWest StraightTrack
	//noStation 1 //stdGauge //orNorthEast StraightTrack
	//noStation 1 //stdGauge //orSouthEast StraightTrack
	0 0 //trackWidth 0 360 arc gsave 1 setgray fill grestore stroke
	0 0 //trackWidth 0.6 mul 0 360 arc fill
} def
%%EndProlog
%%BeginSetup
%%PaperSize: 

%%EndSetup
%%Page: tiles 1
0 4 cuttingTileAvailability
showpage
%%Page: tiles 2
1 4 cuttingTileAvailability
showpage
%%Page: tiles 3
2 4 cuttingTileAvailability
showpage
%%Page: tiles 4
3 4 cuttingTileAvailability
showpage
%%EOF
